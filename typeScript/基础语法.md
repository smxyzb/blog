# 类型注解：冒号 :number 
# 函数类型
```
function add(callback:(string,number)=>void){
  callback()
}

add(()=>{

})

```
# 字面量，组合类型
```
const a:'foo' = 'foo' // 只能等于foo
const type:'success'|'fail'|'danger' = 'success'
const b:string|number = '22'
```

# maybe类型 ? 

```
const val:?number = null
const val:number | null|void = undefined
```

# Mixed 和 any 类型
```
function add(value:mixed){
  if(typeof value === 'number'){
    value*=1
  }
  if(typeof value === 'string'){
    value.substring(0,2)
  }
}
function add(value:any){
  value*=1
  value.substring(0,2)
}
```
区别：Mixed 是强类型的，any 是弱类型的

# 属性或参数的 ?与!
## 属性或参数后面 ? ：表示可有可无
## 属性或参数后面 ! ：表示强制执行解析(告诉typescript编译器，这里一定有值)
## 变量后面 ! ：类型推断会忽略null，undefined 的情况，一定存在

# object 类型：指的基础数据类型以外的类型 

# 数组类型 Array<type>, type[]
```
function sum(...args:number[]){
  return args.reduce((prev,current)=>prev+current,0)
}
```

# 元组类型: 已知元素数量和类型的数组 
```
const arr:[number,string] = [18,'3333'] 
```

# 类型声明 , 当ts 能够自动推断类型的时候就不不需要定义类型
## declare ,第三方或者未声明类型的模块
```
import {camelCase} from 'lodash'
declare func (alias) camelCase(input:string):string
```

# 联合类型：由两个或多个类型组成的类型声明。使用的时候需要注意使用类型的判断
```
const a:number|string  = 1
```

# 类型别名：给类型定义一个别名，实现复用 Type xxx = ''
```
Type Obj = {
  a:string
  b:string
  c:number
}
```
## 类型扩展 & 
```
type Animal {
  name:string
}

type Bear = Animal & {
  age:number
} 

const bear: Bear = {
  name:'dog',
  age:1
}
```

# 接口 interface ：定义对象类型的方式
```
interface Obj {
  a:string
  b:string,
  c:number
}
```
## 类型扩展 extends
```
interface Animal {
  name:string
}

interface Bear extends Animal {
  age:number
} 

const bear :Bear = {
  name:'dog',
  age:1
}
```

## 向已有的接口里面添interface加定义字段
```
interface Animal {
  name:string
}
interface Animal {
  age:string
}
const bear:Animal = {
  name:'dog',
  age:1
}
```

# 类型断言 as ,<HTMLCanvasElement>
```
const ele = document.getElementById('canvas') as HTMLCanvasElement
const ele2 = <HTMLCanvasElement>document.getElementById('canvas')

```

## 文字类型
```
const req = {
  url:'www.baidu.com',
  method:"GET"
}
const request = (url:string,method:'GET'|'POST'|'DELETE')=>{}
request(req.url,req.method) // 类型“string”的参数不能赋给类型“"GET" | "POST" | "DELETE"”的参数
// 解决方法
const req = {
  url:'www.baidu.com',
  method:"GET"
} as const
```
## null 和 undefined （tsconfig 配置 strictNullChecks ）
```
let x:undefined = undefined
let y:null = null
```

# 枚举 enum 
```
enum Direction {
  UP=1,
  DOWN2,
  RIGHT=3,
  LEFT=4
}
```

# BigInt 和 Symbol 
```
const a:bigint = BigInt(100)
const b = Symbol('222')
```

# 类型缩小
## 利用 typeof 类型守卫
```
function(srtrs:string|string[]|number) {
  if(typeof strs === 'string'){

  } else {

  }
}
```
## 真值缩小 
```
if(xxx){}
const bool = Boolean(xxx)
const bool2 = !!xxx
```

## 等值缩小
```
function test(x:string|undefined,y:string){
  if(x===y){
    x.toUpperCase()
    y.toUpperCase()
  }
}
```
## in 缩小，value in xxx
```
type Fish = {swim:()=>void}
type Bird = {fly:()=>void}
function move(animal:Fish|Bird){
  if('swim' in animal){
    animal.swim()
  }  else {
    
  }
}
```

## instanceof : x instanceof Foo
```
if (x instanceof Foo){}

```

## 控制流分析
```
function test(){
  let x:number|boolean|string = Math.random() > 0.5
  if(Math.random() < 0.5){
    x = 'hello'
  } else {
    x = 100
  }
  return x
}
let x = test()
x = 200
x = true // 不能将类型“boolean”分配给类型“string | number”
```
这里设置 x = true 的时候报错，因为 test 返回的类型已经被覆盖了变成了 string | number

## 类型谓词 xxx is xxxType：如果条件满足则 pet 是 Fish
```
type Fish = {swim:()=>void,name:'fish'}
type Bird = {fly:()=>void,name:'bird'}

function isFish(pet:Fish|Bird): pet is Fish {
  return (pet as Fish).swim !== undefined
}
isFish({swim:()=>{},name:'fish'})

```

## 联合类型 unions 中的可选字段类型
```
interface Shape {
  kind:'circle'|'rect'
  radius?:number
  sideLength:number
}

function getArea(shape:Shape) {
  return Math.PI * shape.radius**2 // shape.radius 对象可能为“未定义”
}
```
### 解决办法拆分类型定义，加条件判断缩小(适用于大多数场景)
```
interface Rect {
  kind:'rect'
  sideLength:number
}

interface Circle {
  kind:'circle'
  radius:number
  sideLenght:number
}

type Shape =  Rect | Circle

function getArea(shape:Shape) {
  if(shape.kind ==='circle'){
    return Math.PI * shape.radius**2 // shape.radius 对象可能为“未定义”
  } else {
    return shape.sideLength**2
  }
}

```

## 穷尽检查 never ，never 可以赋给任意类型，但任意类型都不能赋never类型


# 函数类型
## 调用签名:也叫类型签名，或方法签名，定义了函数或方法的输入与输出
```
class Ctor {
  s:string
  constructor(s:string){
    this.s = s
  }
}

type Some = {
  new  (s:string):Ctor
}


function fn(ctor:Some){
  ctor('hello')
}
```
## 构造签名 new 
```
class Ctor {
  s:string
  constructor(s:string){
    this.s = s
  }
}

type Some = {
  new  (s:string):Ctor
}

function fn(ctor:Some){
  return new ctor('hello')
}

const f = fn(Ctor) // Ctor {s:hello}

```

## 泛型函数和类型推断 <Type> / <T>:定义输入与输出类型一致
```
function firstEle<Type>(arr:Type[]):Type |undefined{
  return arr[0]
  // return 100 // 不能将类型“number”分配给类型“Type”
}

firstEle([1,2,3])
```
或者
```
function map<Input,Output>(arr:Input[],func:(arg:Input)=>Output):Output[] {
  return arr.map(func)
}
var s = map(['1','2','3'],(n)=>parseInt(n))
console.log(s);
```

## 泛型函数限制条件
```
function leng<Type extends {length:number}>(a:Type,b:Type) {
  if (a.length >=b.length) {
    return a
  } else {
    return b
  }
}
```
泛型参数 a,b 不一定有length 属性，此时可以使用extends 进行扩展限制,限制必须有某个属性

## 泛型函数的使用受限值
```
function leng<Type extends {length:number}>(a:Type,b:number):Type {
  if (a.length >=b) {
    return a
  } else {
    return {length:b} // 不能将类型“{ length: number; }”分配给类型“Type”。"{ length: number; }" 可赋给 "Type" 类型的约束，但可以使用约束 "{ length: number; }" 的其他子类型实例化 "Type"。ts(2322)
  }
}
const a = leng([1,2,3],3)
```

## 泛型函数指定类型参数
```
function combine<Type>(arr1:Type[],arr2:Type[]):Type[] {
  return arr1.concat(arr2)
}

const arr = combine([1,2,3],['string']) // 不能将类型“string”分配给类型“number”
const arr1 = combine<number|string>([1,2,3],['string'])
```
泛型函数会自动以第一个参数类型推断返回类型，所以第一次直接报错，第二次使用类型指定了传入类型

## 编写优秀通用函数准则
### 可能的情况下，使用类型参数本数本身，而不是对其进行约束;
### 总是尽可能减少地使用类型参数；
### 如果一个类型的参数只出现在一个地方，请重新考虑你是否真的需要它。

##  回调函数中的可选参数问题：注意可选参数的使用

## 函数重载