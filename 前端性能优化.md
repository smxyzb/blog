
###一次 Vue 项目的优化，首屏从将近10s 优化到秒开 
	首先介绍下项目，是一个电商管理的商家后台和公司运维管理后台总共两个。使用的是 基于vue 的iview ui框架进行开发。三人合作，由于我来之前就有一个前同事已经把基本框架都搭建好了，已经做了部分功能，第一天拿到项目，大概扫了 一下，不是很好。
	当时一一向同事咨询了几个问题，得到的回答不尽人意，其中提到测试环境带宽只有1m，上线后会增加带宽。于是就没太多在意。
##原因以下几点：结构略显混乱、未使用成熟的功能插件比如ajax请求、打包时间太久、外网访问首屏加载非常慢，大概需要10s。
	上线后发现还是一样的问题。后来自己主导了一次全面的优化：
	首先看一个打包截图：
	![Image text](https://github.com/smxyzb/blog/blob/master/img/pack1.png)

	打包时间将近40s

	分析原因：主要就是依赖包过多、多处使用同一个包，导致多次重复打进同一个包

	![Image text](https://github.com/smxyzb/blog/blob/master/img/pre.png)

	经检查配置文件，已经做了提取公共包的处理，vendor 文件打出来有242k左右，css文件 228k，appjs 176k，三个家再来640k左右
	查阅资料发现 vue-cli 的一些默认配置是相对比较简单的
```
		new webpack.optimize.UglifyJsPlugin({
			compress: {
				warnings: false,
				drop_console: true,
				pure_funcs: ['console.log']
			},
			sourceMap: false
		})
```
	参照文档做了些修改
```
		new UglifyJsPlugin({
			uglifyOptions: {
				ie8: false,
				ecma: 8,
				mangle: true,
				output: { 
					comments: false //干掉注释
				},
				compress: {
					warnings: false,
					drop_console: true,//去除调试信息console
					pure_funcs: ['console.log']
				}
			},
			sourceMap: false,//不生成sourceMap文件
			cache: true,//缓存
			parallel: os.cpus().length * 4 //cpu 加速打包
		})
```

	其中还有首屏的背景图进行了压缩，大小减少至60k左右，是原来的一半。
	尝试打包三发现效果不是很理想，也不是没有效果，时间减少了3-5秒，上测试环境访问依然慢。
	再看网络请求：
	![Image text](https://github.com/smxyzb/blog/blob/master/img/cms1.png)
	
	![Image text](https://github.com/smxyzb/blog/blob/master/img/cms3.gif)
	下载其中几个比较大的文件耗时比较多，其中md5，echarts，xlsx 都是静态文件，没有可优化的空间，主要考虑前面几个经过打包的文件
	于是找到main js，这是使用了大量的 component 
	![Image text](https://github.com/smxyzb/blog/blob/master/img/main.js1.gif)
	想办法让这些组件都不打包进去，但是又要能用，抱着试试的态度注释掉所有import 进来的组件，把iview 换成了通过cdn引入
	![Image text](https://github.com/smxyzb/blog/blob/master/img/mian.js.png)
	![Image text](https://github.com/smxyzb/blog/blob/master/img/script.png)
	打包发现时间减少3秒左右。
	鉴于项目中 ivew vue vuex vueRouter xlsx md5 echarts 都是通用的 于是又把这些都换成了cdn 引入的方式。
	在组件中吧import 引入的都去掉
	改成
	// import Vue from 'vue';
	// import Router from 'vue-router';
	const Router = VueRouter //这里cdn 引入后 vue-router 会生成一个全局的VueRouter 对象所以直接用
![Image text](https://github.com/smxyzb/blog/blob/master/img/router.png)

	打包时间猛降到12s 左右，几个打包文件也较少到几十k

	![Image text](https://github.com/smxyzb/blog/blob/master/img/pack2.png)

	再看网络请求

	![Image text](https://github.com/smxyzb/blog/blob/master/img/cms4.gif)

	![Image text](https://github.com/smxyzb/blog/blob/master/img/cms2.png)
	基本差不多做到了秒开

	cdn 引用后面几个采用动态生成script 插入的方式，主要是插件不是马上用的，为了不印象其他加载，我在页面加载完成再来加载他们，这样网速教程的时候不至于卡太久，用户也能比较快的使用登陆功能的操作
	
	

### <h3>函数的节流与防抖 </h3> 
##函数节流：简单概括就是限制频率。
为了避免频繁的多次，重复操作，将某个步骤限定在一定时间内只执行一次。常见的有滚动加载更多,以一个变量作为标识来进行判断是或否需要执行。    

``` 
var loading = false
document.addlistener('scroll',function(e){
	if(!loading){
		setTimeout(function(){
			// doLoading
			loading = false
		}, 300);
	}
})
```  

##函数防抖：限制到最后一次触发后再调用
频繁触发的情况下，将其限制在特定时间内没有触发动作(条件)后再执行。常见的有监听页面滚动、检测用户输入手机，邮箱等
``` 
var timer = null;
document.getElementById("debounce").onscroll = function(){
    clearTimeout(timer);  //连续触发的时候，注意每次都要清除一下定时器，重新开始计时
    timer = setTimeout(function(){
        //doSomething
    }, 300);
};  
```  

### <h3>雅虎军规35条。 </h3> 
1.尽量减少 HTTP 请求个数 ：然而并不是http请求越少越好，根据需要适当增减，像webpack 打包后首屏加载缓慢的这个时候应该把模块拆分成n个，进行按需加载  
2.使用 CDN（内容分发网络）：从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均而产生的用户访问网站响应速度慢的根本原因，提高用户访问网站的响应速度。  
3.为文件头指定 Expires 或 Cache-Control ，使内容具有缓存性：浏览器在一次请求后会缓存起来某些文件，当下次在请求的时候，会先检查有没有缓存，有则看是否过期，没有过期则直接使用缓存，过期了则从新发起http请求。 <a href='https://h.lishaoy.net/webOptimize.html'>图片来源</a>
	![Image text](https://github.com/smxyzb/blog/blob/master/img/webCache4.png)
	缓存类型：
	<table>
		<thead><tr><td>缓存策略</td><td>获取资源形式</td><td>状态码</td><td>发送请求到服务器</td></tr></thead>
		<tbody>
			<tr><td>强缓存</td><td>从缓存取</td><td>200（from memory cache）</td><td>否，直接从缓存取</td></tr>
			<tr><td>协商缓存</td><td>从缓存取</td><td>304（not modified）</td><td>是，通过服务器来告知缓存是否可用</td></tr>
		</tbody>
	</table>
4.避免空的 src 和 href  
5.使用 gzip 压缩内容：服务端Gzip开启以后会将输出到用户浏览器的数据进行压缩的处理，这样就会减小通过网络传输的数据量，提高浏览的速度  
6.把 CSS 放到顶部  
7.把 JS 放到底部  
8.避免使用 CSS 表达式  
9.将 CSS 和 JS 放到外部文件中  
10.减少 DNS 查找次数  
11.精简 CSS 和 JS  
12.避免跳转  
13.剔除重复的 JS 和 CSS  
14.配置 ETags  
15.使 AJAX 可缓存  
16.尽早刷新输出缓冲  
17.使用 GET 来完成 AJAX 请求  
18.延迟加载  
19.预加载  
20.减少 DOM 元素个数  
21.根据域名划分页面内容  
22.尽量减少 iframe 的个数  
23.避免 404  
24.减少 Cookie 的大小  
25.使用无 cookie 的域  
26.减少 DOM 访问  
27.开发智能事件处理程序    
28.用 link 代替 @import  
29.避免使用滤镜  
30.优化图像  
31.优化 CSS Spirite  
32.不要在 HTML 中缩放图像  
33.favicon.ico要小而且可缓存  
34.保持单个内容小于25K  
35.打包组件成复合文本  





