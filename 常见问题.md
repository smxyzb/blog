## 原型链 **proto**与 prototype 的关系

### 实例的 ** proto** 属性等于构造函数的原型，继承主要通过**proto**实现

```
function Animal(name) {
  this.name = name
}
Animal.prototype.bark = function () {
  console.log('bark');
}

var d = new Animal()

console.log(d.__proto__ === Animal.prototype);
```

同样:几种数据类型的 **proto** === Function.prototype

## meta 标签的 http-equiv content 的 cache-control 几个值的区别

```
1、max-age：单位是秒，缓存时间计算以发起时间的秒数计算，超过设置的时间则失效。

2、no-cache：不使用缓存，需要与服务器验证缓存新鲜度，也就是协商缓存。

3、no-store：禁止使用缓存（包括协商缓存）,每次都想服务器发起请求新的资源。

4、private：专用于个人缓存，中间代理、CDN 等不能缓存次响应。

5、public：响应可悲中间代理，CDN 等缓存。

6、must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证。
```

## react 和 Vue 的区别

## redux 和 Vuex 的区别

## EventLoop

## 主线程，微任务，宏任务，Promise 是什么任务

### Event Loop 是一个程序结构，用于等待和发送消息和事

## for forEach for in for of

## 如何捕获 await 内部错误

## 常用布局和适配方式

## flex 布局，flex 有哪些属性

## 居中问题

## 原生小程序 Object 的不写方法的兼容性

## http2

## 函数科里化：所谓"柯里化"，就是把一个多参数的函数，转化为单参数函数

### 只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数

### 代码复用，减少维护成本

### 尽可能的函数化，便于阅读

## 防抖，节流原理，使用场景

#### 防抖(debounce)：高频触发的事件，每次触发之前都会取消上一次的延迟调用，并重新计时

```
function debounce(fn,wait,immedidate){
  let timer = null;
  return function(){
    if(timer) clearTimeout(timer)
    let agrs = arguments
    let context = this
    if(immedidate){
      // 立即执行一次
      let callNow = !timer
      timer = setTimeout(()=>{
        timer = null
      },wait)
      if(callNow) fn.apply(context,agrs)
    } else {
      timer = setTimeout(()=>{
        fn.apply(context,agrs)
      },wait)
    }
  }
}
```

#### 使用场景：input 输入联想功能， window.resize 事件， onmousemove

### 节流(throuttle)：高频触发的事件，固定时间内只触发一次，通常以加锁配合定时器的方式

```
function throuttle(fn,wait){
  let locked = false
  return function(){
    if(locked) return
    let agrs = arguments
    let context = this
    locked = true
    setTimeout(()=>{
      fn.call(context,agrs)
      locked = false
    },wait)
  }
}

// 复杂版
function throttle(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
        previous = options.leading === false ? 0 : new Date().getTime();
        timeout = null;
        func.apply(context, args);
        if (!timeout) context = args = null;
    };

    var throttled = function() {
        var now = new Date().getTime();
        if (!previous && options.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            func.apply(context, args);
            if (!timeout) context = args = null;
        } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
        }
    };
    return throttled;
}
```

#### 使用场景：window.scroll 事件，按钮频繁点击

## 实现 New 方法，apply，call，bind

```

function New() {
  // 1、创建一个空的对象
  var obj = new Object();
  // 2、获得构造函数，同时删除 arguments 中第一个参数 console.log(arguments);
  var Con = [].shift.call(arguments);
  console.log(Con);
  // 3、链接到原型，obj 可以访问构造函数原型中的属性
  Object.setPrototypeOf(obj, Con.prototype);
  // 4、绑定 this 实现继承，obj 可以访问到构造函数中的属性
  var ret = Con.apply(obj, arguments); console.log(ret);
  // 5、优先返回构造函数返回的对象
  return ret instanceof Object ? ret : obj; };

```

## 数据类型判断， instanceof 是怎么判断是不是父类的实例的

### typeof：对于{},[],null 都会返回 object，并不能知道具体类型

### Object.prototype.toString.call(obj)

```
Object.prototype.toString.call([]) === "[object Array]"
Object.prototype.toString.call({}) === "[object Object]"
Object.prototype.toString.call(null) === "[object Null]"
Object.prototype.toString.call('') === "[object String]"
Object.prototype.toString.call(undefined) === "[object Undefined]"
```

### instanceof：判断一个引用类型是否属于耨个构造函数，还可以在继承关系中来判断一个实例是否属于他的父类

```
// 实现原理
function instance_of(L,R){
  let O = R.prototype
  let L = L.__proto__
  while(true){
    if(L === null) rteurn false
    if(O===L)
      return true

    L = L.__proto__
  }
}
```

## Nginx 缓存配置，负载均衡

## 前端性能优化

## 组件封装设计思路

## 架构思想

## Webworker

## Git 流程

## 堆栈，const 为啥能修改引用类型的数据，怎么样不能修改

## Set get 里面做了啥

## 引用类型的存储

