## websocket 保障

# 心跳检测和重连机制

1、创建 WebSocket 链接

```
function createWebSocket() {
  try {
    ws = new WebSocket(wsUrl);
    init();
  } catch(e) {
    console.log('catch');
    reconnect(wsUrl);
  }
}
```

2、初始化，利用 close 或者 error 方法

```
ws.onclose = function () {
  reconnect(url)
}

ws.onerror = function () {
  reconnect(url)
}

ws.onpoen = function () {
  // 心跳检测
  heartCheck.start()
}

ws.onmessage = function (event) {
    console.log('接收到消息');
    //拿到任何消息都说明当前连接是正常的
    heartCheck.start();
}

```

3、重连操作

```
var lockReconnect = false;//避免重复连接
function reconnect(url) {
      if(lockReconnect) {
        return;
      };
      lockReconnect = true;
      //没连接上会一直重连，设置延迟避免请求过多
      tt && clearTimeout(tt);
      tt = setTimeout(function () {
        createWebSocket(url);
        lockReconnect = false;
      }, 4000);
}
```

4、心跳检测

```
//心跳检测
var heartCheck = {
      timeout: 3000, //每隔三秒发送心跳
      num: 3,  //3次心跳均未响应重连
      timeoutObj: null,
      serverTimeoutObj: null,
      start: function(){
        var _this = this;
        var _num = this.num;
        this.timeoutObj && clearTimeout(this.timeoutObj);
        this.serverTimeoutObj && clearTimeout(this.serverTimeoutObj);
        this.timeoutObj = setTimeout(function(){
              //这里发送一个心跳，后端收到后，返回一个心跳消息，
              //onmessage拿到返回的心跳就说明连接正常
              ws.send("123456789"); // 心跳包
              _num--;
              //计算答复的超时次数
              if(_num === 0) {
                   ws.colse();
              }
        }, this.timeout)
      }
}
```

## 原型链 **proto**与 prototype 的关系

### 实例的 ** proto** 属性等于构造函数的原型，继承主要通过**proto**实现

```
function Animal(name) {
  this.name = name
}
Animal.prototype.bark = function () {
  console.log('bark');
}

var d = new Animal()

console.log(d.__proto__ === Animal.prototype);
```

同样:几种数据类型的 **proto** === Function.prototype

## meta 标签的 http-equiv content 的 cache-control 几个值的区别

```
1、max-age：单位是秒，缓存时间计算以发起时间的秒数计算，超过设置的时间则失效。

2、no-cache：不使用缓存，需要与服务器验证缓存新鲜度，也就是协商缓存。

3、no-store：禁止使用缓存（包括协商缓存）,每次都想服务器发起请求新的资源。

4、private：专用于个人缓存，中间代理、CDN 等不能缓存次响应。

5、public：响应可悲中间代理，CDN 等缓存。

6、must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证。
```

## 怎么理解 Vue 的渐进式

## Vue mergeOption 规则

## Vue 数组改变不重写方法

## diff 过程

## Vue-router 组件有那几个

## mixins 嵌套原理，Vuex Module 嵌套，extends

## Observer Compiler Wacther 的作用

## BeforeROuterEnter ，BeforeRouterLeave，参数，router 导航方法，跳转方式

## 组件多，页面卡顿的优化

## Vue 依赖收集过程，原理

## Vue 列表位置缓存，列表到详情再返回怎么保证停留在原来的位置

### keep-alive 组件，使组件缓存起来，不被销毁

### scrollBehavior

```
        scrollBehavior = function (to, from, savedPosition) {
          if (savedPosition) {
            return savedPosition
          } else {
            return { x: 0, y: 0 }
          }
          if (to.hash) {
            return {
              selector: to.hash
            }
          }
        }
```

### 控制滚动

```
window.scrollTo(0, 1);
```

## Vue Core 模块主要关注什么，主要任务

## v-model 的实现，sync 的实现原理，如何使用他们来封装组件

## created ，beforeUpdated 里面更改数据会出发 update 吗

## Vue mounted 循环为什么不会一直更新

## react 和 Vue 的区别

## redux 和 Vuex 的区别

## let，const 为什么不能重复定义

## Set 和 Map 是基于什么来遍历的，iterator 未完成时候 next 是什么

## Promise all trace 在其中有个 resolve 或者 reject 的情况

## EventLoop

## 主线程，微任务，宏任务，Promise 是什么任务

### Event Loop 是一个程序结构，用于等待和发送消息和事

## for forEach for in for of

## 如何捕获 await 内部错误

## es6 数组新方法有哪些，reduce 的用法

## ex6 Proxy 与 Reflect 的关系

## class 里面的 super 与 this 的区别

## 常用布局和适配方式

## flex 布局，flex 有哪些属性

## 居中问题

## 原生小程序 Object 的不写方法的兼容性

## http2

## webpack Tree-shaking 原理

## Electron 通讯，主进程与渲染进程的通讯

## webpack 怎么与 CDN 结合使用

## webpack Loader 和 plugin 的区别，分别在 webpack 的什么时间执行

### Loader 用于对源码的转换，它描述了 webpack 如何处理非 js 模块，并且在 build 中引入这些依赖。loader 可以将其他东西转换成 JavaScript 语言。在 config 中的 module.rules 中配置，可使用 option 参数进行配置

### plugin 可以为 loader 带来更多特性，目的在于结局 loader 不能解决的事情，从打包优化、压缩、环境变量等等

#### 比如：webpack3 中 commonChunkPlugin 用于提取第三方库和公共模块。

````
    new webpack.optimize.CommonsChunkPlugin({
        name: ['vendor','runtime'],
        filename: '[name].js',
        chunks: ['vendor']
    });
```
#### 在webpack4中 使用 optimization 进行配置splitChunks

```
configureWebpack: {
    optimization: {
      splitChunks: {
        minChunks: 2,
        minSize: 20000,
        maxAsyncRequests: 20,
        maxInitialRequests: 30,
        name: false
      }
    }
}
````

## 函数科里化：所谓"柯里化"，就是把一个多参数的函数，转化为单参数函数

### 只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数

### 代码复用，减少维护成本

### 尽可能的函数化，便于阅读

## 防抖，节流原理，使用场景

## Promise 实现，手写 Promise

## Promise all trace 有一个 resolve，reject 的时候结果

## 实现 New 方法，apply，call，bind

````

function New() { // 1、创建一个空的对象 var obj = new Object(); // 2、获得构造函数，同时删除 arguments 中第一个参数 console.log(arguments); var Con = [].shift.call(arguments); console.log(Con); // 3、链接到原型，obj 可以访问构造函数原型中的属性 Object.setPrototypeOf(obj, Con.prototype); // 4、绑定 this 实现继承，obj 可以访问到构造函数中的属性 var ret = Con.apply(obj, arguments); console.log(ret); // 5、优先返回构造函数返回的对象 return ret instanceof Object ? ret : obj; };

```

## Nginx 缓存配置，负载均衡

## 前端性能优化

## 组件封装设计思路

## 架构思想

## 二叉树

### 实现

### 获取二叉树深度

```

var maxDepth = function (root) { if (root === null) { //注意等号 return 0; } else { var leftDepth = 0; var rightDepth = 0 if (root) { console.log(root); leftDepth = maxDepth(root.left) console.log(leftDepth); rightDepth = maxDepth(root.right) console.log(rightDepth); } var childDepth = leftDepth > rightDepth ? leftDepth : rightDepth;

    return childDepth + 1;//根节点不为空高度至少为1

} };

```

## 函数柯理化的实现

```

add(1)(2)(3) add(1,2)(3)

```

## 让 for of 能遍历对象

```

let obj = { data: {

}, a: 1, b: 3, c: function name(params) {

}, [Symbol.iterator]() { let keyArr = Object.keys(obj) let index = 0 return { next() { return index < keyArr.length ? { value: { key: keyArr[index], val: obj[keyArr[index++]] } } : { done: true } } } } }

for (const iterator of obj) { console.log(iterator); }

```

## 你如何理解 react 和 vue？

## react 或 vue 组件中的 key

## 数据状态管理

## webpack 组件异步加载原理

## 介绍一个你认为有意思的项目

## 如何理解 redux？

## redux 中间件原理

## 高级组件

## hooks

## redux 数据流优化
```
````
