#### 资源加载顺序：利用标签属性控制资源加载

1、preload

```
<link rel="preload" href="/path/to/style.css" as="style">
```

preload 提供了一种声明式的命令，让浏览器提前加载指定资源(加载后并不执行)，需要执行时再执行这样做的好处在于：

1、将加载和执行分离开，不阻塞渲染和 document 的 onload 事件。

2、提前加载指定资源，避免某些样式在一段时间后才展示出来。

as 表示以什么样的资源类型加载资源，浏览器会根据 as 值发送具体点的 accept header 信息，当资源相同时可重用等。

错误点的 as 值则会被浏览器解析成 XHR 请求，导致加载优先级降至最低，应避免错误的 as 值。 <strong>preload 不会阻塞 windows 的 onload 事件 </strong>

<strong>preload 跨域加载资源的时候，必须加上 crossorigin 属性 </strong>

<strong>对于 preload 资源的 as 值不明确的时候，浏览器会二次加载资源，造成网络资源浪费</strong>

2、prefetch

```
<link rel="preload" href="./app.js" as="script">
<link rel="prefetch" href="./app.js">
```

prefetch 是告诉浏览器页面可能需要的资源，但不一定会加载这些资源，主要用于对于页面将来可能用到的资源加载。 比如在 Vue 的 ssr 中，首页资源均使用 preload 进行加载，而不使用 prefetch。应该避免 preload 和 prefetch 同时使用，不然会重复加载资源。

3、defer 和 async ：主要用于 script 加载一个图说明： <img src='https://github.com/smxyzb/blog/blob/master/img/2151798436-59da4801c6772_articlex.png' style='height:200px;'>

一般的 script 加载时在 html 加载完成后进行；

使用 scync 的 script 会不受其他 html 加载的影响，会进行异步加载，加载完成后会立即执行；

使用 defer 的 script 同样不受 html 加载的影响，加载过程与 scync 一样，只是执行方式不一样，他会被安排到 html 全部加载完成后再执行，也就是对执行时间进行了延迟；

<strong>有 defer 属性的脚本执行也不一定按照顺序执行</strong>

#### 缓存

### http 缓存

## 强缓存

# Pragma：只有一个属性值 no-cache ，效果和 Cache-control 一致，不使用强缓存，需要与服务器验证缓存新鲜度，在三个头部属性中优先级最高

# Cache-control：常用的属性有

1、max-age：单位是秒，缓存时间计算以发起时间的秒数计算，超过设置的时间则失效。

2、no-cache：不使用缓存，需要与服务器验证缓存新鲜度，也就是协商缓存。

3、no-store：禁止使用缓存（包括协商缓存）,每次都想服务器发起请求新的资源。

4、private：专用于个人缓存，中间代理、CDN 等不能缓存次响应。

5、public：响应可悲中间代理，CDN 等缓存。

6、must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证。

# Expires：在三个头部属性中优先级最低

```
<meta http-equiv="Expires" content='0'/>
```

<strong>如果在 Cache-Control 响应头设置了 "max-age" 或者 "s-max-age" 指令，那么 Expires 头会被忽略。</strong>
