#### 构造函数继承
		```  
		function animal(name){
			this.name = name
			this.sleep = function(){
				console.log(`${name} has sleep property`)
			}
		}
		animal.prototype.eat = function (){
			console.log(`${this.name} has eat property`)
		}
		function friend(name){
			this.name = name
			this.isFriend = function(){
				console.log(`${this.name} is our friend`)
			}
		}
		function dog(name){
			this.name = name;
			animal.call(this,name);
			friend.call(this,name);
		}
		var gou = new dog('哈士奇');
		console.log(gou.name);//哈士奇
		console.log(gou.sleep());//哈士奇 has eat property
		console.log(gou.isFriend());//哈士奇 is our friend
		console.log(gou instanceof animal);//false
		console.log(gou instanceof friend);//false
		console.log(gou instanceof dog);//true  
		```
		// 优点:可以实现多次继承 call apply，并且能够向父类传递参数
		// 缺点：实例不是父类的实例,实例是子类的实例，只能继承父类的实例属性和方法，不能继承原型属性方法，也无法实现函数复用，每个子类都是父类实例函数的副本，影响性能。


####原型链的继承
		//把父类的实例作为子类的原型
		```  
		function Cat(){ }
		Cat.prototype = new animal();
		var cat = new Cat();
		cat.sleep();// cat has sleep property
		cat.eat();// cat has eat property
		cat instanceof Cat //true	
		cat instanceof animal//true	  
		```
		//优点：实现简单，最终的子类cat是父类的实例，也是子类Cat的实例,父类新增属性方法子类都能访问到
		//缺点：要为子类新增方法必须在实例化之后，无法实现多继承，无法向父类的构造函数传递参数，原型对象上的属性是所有实例共享的

####通过实例继承
		```  
		function mouse(name){
			var instance = new animal(name)
			instance.anme = name||'animal';
			return instance
		}
		var dog = new mouse('jerri')
		console.log(dog.sleep());// jerri has sleep property
		console.log(dog.eat());// TypeError dog.eat is not a function
		dog instanceof animal //true
		dog instanceof mouse //false  
		```
		//优点：可向父类传递参数
		//缺点：实例是父类的实例，不是子类的实例


####通过拷贝继承
		```
		function mouse(name){
			var animal = new animal(name);
			mouse.prototype.name = name
			for(let item in animal){
				mouse.prototype[item] = animal[item]
			}
		}
		var m = new mouse('jerri');
		console.log(m.sleep())// jerri has sleep property
		console.log(m.eat())// jerri has eat property
		console.log(m instanceof mouse);//true
		console.log(m instanceof animal);// false  
		```
		//优点：可向父类传参，支持多重继承
		// 缺点：效率低，占用内存大，无法获取父类不可枚举（for in无法遍历到）的属性方法

####组合继承
		//集成构造函数，原型的优点
		```  
		function Animal(name){
			this.name = name
		}
		Animal.prototype.walk = function(){
			console.log(`${this.name} can walk`)
		}
		function Cat(name){
			animal.call(this);
			this.name = name;
		}		
		Cat.prototype = new Animal('Tom')
		Cat.prototype.constructor = Cat
		var tom = new Cat('Tom')
		console.log(tom.name);// Tom
		console.log(tom.sleep());// Tom has sleep property
		console.log(tom.walk());// Tom can walk
		console.log(tom.eat());// tom.eat is not a function
		console.log(tom instanceof Animal);//true
		console.log(tom instanceof Cat);//true  
		```
		// 优点：可传参数，实例时子类的实例，也是父类的实例
		//缺点：生成了两次实例，最初的父类原型方法丢失eat

####寄生组合继承
		//借助一个没有实例方法的类
		```  
		function Animal(name){
			this.name = name
			Animal.prototype.walk = function(){
				console.log(`${name} can walk`)
			}
		}
		function Cat(name){
			Animal.call(this,name);
			this.name = name
		}
		var f = function(){}
		f.prototype = Animal.prototype;
		Cat.prototype  = new f()
		var cat = new Cat('Tom')
		console.log(cat.name);// Tom
		console.log(cat.walk())// Tom can walk
		console.log(cat instanceof Cat) ;//true
		console.log(cat instanceof Animal) ;//true  
		```
		//优点：既能实现参数传递，又能实现父类原型方法的继承，实例是子类的实例
		//缺点：稍显复杂

#### class 类继承
		```  
		class Animal extends animal {
			constructor(props){
				super(props);
				this.bark = function(){
					console.log(`${this.name} barking `)
				}
			}
			run(){
				console.log(`${this.name} can run `)
			}
		}
		var dog = new Animal('土狗');
		console.log(dog.bark());// hello 土狗
		console.log(dog.sleep());// 土狗 has sleep property
		console.log(dog.eat());// 土狗 has eat property
		console.log(dog instanceof animal);// true   
		```
		//优点：可实现各种传参，原型的继承
		//缺点：Class类的内部所有定义的方法，都是不可枚举的
