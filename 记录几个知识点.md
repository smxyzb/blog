#### BOM 和 DOM 
	BOM：浏览器对象模型。BOM提供了独立于内容 而与浏览器窗口进行交互的对象；由于BOM主要用于管理窗口与窗口之间的通讯，因此其核心对象
	是window；
<img src='https://github.com/smxyzb/blog/blob/master/img/BOM.jpg'> 
	DOM：文档对象模型。HTML DOM 定义了访问和操作 HTML 文档的标准方法。DOM 将 HTML 文档表达为树结构
<img src='https://github.com/smxyzb/blog/blob/master/img/DOM.png'>  

#### Get POST 的区别
<img src='https://github.com/smxyzb/blog/blob/master/img/getpost.png'>

#### javascript 事件循环  



#### cookie sessionStorage localStorage 的区别
	cookie:存储于本地用于解决记录客户端的用户信息的数据，他会跟随http 请求一起发送到服务端，服务端通过他来读取用户信息，所以cookie
	越小越好，仅在当前会话下有效，有大小限制，最大4k； 不宜存储敏感信息
	
	sessionStorage ：本地临时存储，仅在当前会话下有效，浏览器关闭后清除。最大为5m。不参与http 请求  

	localStorage ：本地永久存储，全部页面共享。不参与http 请求，最大5m
<img src='https://github.com/smxyzb/blog/blob/master/img/storage.png'>	

#### 前端安全

#### git fetch 与 git pull 的区别
	git fetch：这将更新git remote 中所有的远程仓库所包含分支的最新commit-id, 将其记录到.git/FETCH_HEAD文件中   
	git pull : 首先，基于本地的FETCH_HEAD记录，比对本地的FETCH_HEAD记录与远程仓库的版本号，然后git fetch 获得当前指向的远程分支
	的后续版本的数据，然后再利用git merge将其与本地的当前分支合并。所以可以认为git pull是git fetch和git merge两个步骤的结合

#### 浅拷贝与深拷贝
	js 中基本类型存放在栈内存，复合（引用）类型存放在堆内存。
	<strong>重点：深浅拷贝只针对Object和Array 这样的引用类型来讲</strong>，忽略这点那么很多情况下就回进入一个误区。
	比如有下面一段代码：
	```
	var obj = {
		a:123,
		b:[1,2,3],
		c:function(){}
	}
	function copy(o){
		var newObj = {};
		for (let i in o){
			if(o.hasOwnProperty(i)){
				newObj[i] = o[i]
			}
		}
		return newObj;
	}
	var newObj = copy(obj);
	newObj.a;//123
	newObj.a = 345;
	newObj.a;//345
	obj.a;//123 这里不受影响，what fuck 不是说浅拷贝会相互影响么

	newObj.b.push(4);
	newObj.b;//[1,2,3,4]
	obj.b;//[1,2,3,4]
	//到这里我开始怀疑这是深拷贝还是浅拷贝
	```
	因为我忽略了一点就是开头所说的：深浅拷贝只针对引用类型来讲，忽略基本类型。

	复制引用和复制实例，这也是浅复制和深复制的区别所在；
	<strong>浅拷贝</strong>：浅拷贝是拷贝了基本类型的数据，引用类型的则是引用，新对象和旧对象会在引用类型上相互影响。
		```
		var newObj = copy(obj);
		```
	这就是个浅拷贝，修改obj.b 或obj.c 则newObj 也会跟着改变
	所有的快捷操作 如slice splice split 等都是浅拷贝操作；

	<strong>深拷贝</strong>：在堆中重新分配内存，并且把源对象所有属性都进行新建拷贝，以保证深拷贝的对象的引用图不包含任何原有对象或对象图上的任何对象，拷贝后的对象与原来的对象是完全隔离，互不影响。
	常见的深拷贝有 es6 中的 Array.from ，... 扩展，或者使用循环递归的方式进行拷贝

	```
	 function deepCopy(obj,newObj){
		 var newObj = newObj || {};
		 for(let item in obj){
			 if(typeof obj[item] === 'object'){
				 newObj[item] = (obj[item].constructor === Array)?[]:{};
				 deepCopy(obj[item],newObj[item]);
			 }else{
				 newObj[item] = obj[item];
			 }
		 }
		 return newObj;
	 }

	``` 
	对于结构简单的对象来说(对象没有属性是function 的)，使用JSON.parse 和 JSON.stringify 也可以实现深拷贝
	```
	 var obj = {a:'aa',b:function(){},c:[1,2,3,4]}
	 var newObj = JSON.parse(JSON.stringify(obj));

	```
	console.log(newObj);//  {a:'aa',c:[1,2,3,4]}发现属性方法b没了，所以这个方式对于有属性是function的对象不适用


#### resultful 是什么
	resultful 是一种基于http协议实现的设计风格，他提供了一些设计原则和约束条件。用于客户端与服务端的交互，目的是为了提高系统的可伸缩性，降低应用之间的耦合度，方便框架分布式处理程序，可以更加简单、更有层次、更易于实现缓存的机制。
	主要有四种方式：GET、POST、PUT、DELETE
		GET:对应select。从服务器查询,在服务器通过请求的参数区分查询的方式；
		POST：对应Create。在服务器新建立一个资源，调用insert操作；
		PUT：对应update操作。在服务器更新资源，调用update操作。
		DELETE：对应DELETE操作。从服务器删除资源，调用delete语句。

#### 手动实现bind
	```
	Function.prototype.bind(){
		var self = this;
		var ars = Arrary.slice.call(arguments,1);
		var func = function(context){
			var newArs = Array.slice.call(arguments);
			self.call(context,newArs.concat(ars))
		}
		return func
	}
	```
	
#### 函数声明和函数表达式
	函数声明：定义一个函数出来如 function func(){} 的形式
	函数表达式：一直javascript的人语句，包含函数声明;
			var a = function(){}
			+function(){}();
			-function(){}();
			!function(){}();
			~function(){}();
	
#### 一个易出错的面试题,涉及变量提升、作用域、解析、原型等
		function Foo() {
			getName = function () { 
				console.log(1); 
			};
			return this;
		}
		Foo.getName = function () { 
			console.log(2); 
		};
		Foo.prototype.getName = function () { 
			console.log(3); 
		};
		var getName = function () { 
			console.log(4); 
		};
		function getName() { 
			console.log(5); 
		};

		// 请写出以下输出结果：
		Foo.getName(); //2
		getName();//4
		Foo().getName();//1
		getName();//1
		new Foo.getName();//2
