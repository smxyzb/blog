# 常见设计模式

## 单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点

### 核心：确保只有一个实例，并提供全局访问

### 场景：弹窗，dialog, message

## 策略模式：定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换

### 核心：将算法的使用和算法的实现分离开来。

-   一个基于策略模式的程序至少由两部分组成：

-   第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。

-   第二个部分是环境类 Context，Context 接受客户的请求，随后把请求委托给某一个策略类。要做到这点，说明 Context 中要维持对某个策略对象的引用

### 场景：表单的验证

```
function Validator() {
    this.items = [];
};

Validator.prototype = {
    constructor: Validator,
    // 添加校验规则
    add: function(value, rule, errorMsg) {

    },

    // 开始校验
    start: function() {}
```

## 代理模式：为一个对象提供一个代用品或占位符，以便控制对它的访问

### 核心：中间代理处理请求，在把请求发送给主体，类似中间件

### 场景：拦截器，过滤器

```
// 主体，发送消息
function sendMsg(msg) {
    console.log(msg);
}
// 代理，对消息进行过滤
function proxySendMsg(msg) {
    // 无消息则直接返回
    if (typeof msg === 'undefined') {
        console.log('deny');
        return;
    }
    // 有消息则进行过滤
    msg = ('' + msg).replace(/泥\s*煤/g, '');

    sendMsg(msg);
}

proxySendMsg('泥煤呀泥 煤'); // 呀
```

## 迭代器模式

## 发布-订阅模式

## 命令模式

## 组合模式

## 装饰器模式

## 适配器模式

## 模版方法模式

## 享元模式

## 职责链模式

## 中介者模式

## 状态模式

## 外观模式

# 设计模式的六大原则

## 单一原则（Single Responsibility Principle）：一个类或者一个方法只负责一项职责，尽量做到类的只有一个行为原因引起变化；

a、业务对象（BO business object）、业务逻辑（BL business logic）拆分；

## 里氏替换原则（LSP liskov substitution principle）：子类可以扩展父类的功能，但不能改变原有父类的功能；（本质其实就是 c++的多态）

（目的：增强程序的健壮性）实际项目中，每个子类对应不同的业务含义，使父类作为参数，传递不同的子类完成不同的业务逻辑。

## 依赖倒置原则（dependence inversion principle）：面向接口编程；（通过接口作为参数实现应用场景）

抽象就是接口或者抽象类，细节就是实现类

含义：

上层模块不应该依赖下层模块，两者应依赖其抽象；

抽象不应该依赖细节，细节应该依赖抽象；

通俗点就是说变量或者传参数，尽量使用抽象类，或者接口；

【接口负责定义 public 属性和方法，并且申明与其他对象依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑】

## 接口隔离（interface segregation principle）：建立单一接口；（扩展为类也是一种接口，一切皆接口）

定义：

a.客户端不应该依赖它不需要的接口；

b.类之间依赖关系应该建立在最小的接口上；

简单理解：复杂的接口，根据业务拆分成多个简单接口；（对于有些业务的拆分多看看适配器的应用）

【接口的设计粒度越小，系统越灵活，但是灵活的同时结构复杂性提高，开发难度也会变大，维护性降低】

## 迪米特原则（law of demeter LOD）：最少知道原则，尽量降低类与类之间的耦合；

一个对象应该对其他对象有最少的了解

## 开闭原则（open closed principle）：用抽象构建架构，用实现扩展原则；（总纲）

（solid 稳定的 记忆首字母）

# vue 使用的什么设计模式
