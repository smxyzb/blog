#### 执行上下文
1、全局执行上下文
2、函数执行上下文
3、Eval 执行上下文

### 执行栈：也叫调用栈，具有(LIFO)后进先出的结构，用于存储代码执行期间创建的所有执行上下文
首次运行时会创建一个全乎执行上下文并push 到当亲的执行栈中，当发生函数调用的时候，会为改函数创建一个新的函数执行上下文并push当前执行栈的顶部，当函数执行完成后，其对应的执行上下文会从执行上下文中POP出来，上下文控制权将转移到当前执行栈的下一个执行上下文


### this 指向
## 全局执行上下文中，this 指向全局对象，浏览器中指向window 对象，在nodejs环境中，this指向这个文件的module对象
## 函数执行上下文中，this 的指向取决于函数的调用方式，谁调用指向谁

### 词法环境（全局环境和函数环境）
## 环境记录：存储变量和函数声明的实际位置
## 对外不换的的引用：可以访问其外部词法环境

### 堆栈
## 栈内存：基本类型 Undefined、Null、Boolean、Number 、String和Symbol 都保存在栈内存中，因为这些数据在内存中的空间大小都是固定的，通过安智来访问
## 堆内存：引用类型数据都保存在堆内存中，因为这种值的大小不固定，但是内存地址大小是固定的，当使用的时候会先从栈内存中读取内存地址，然后再通过地址找到堆内存中的值，叫做按引用访问

### 内存机制
## 内存回收
1、局部作用于总，函数指执行完成后各种局部变量就被销毁了
2、全局作用域中，全局变量什么时候释放销毁很难判断，所以应尽量避免使用全局变量

V8 引擎内存机制（对象）：
初始分配：生命并赋值变量的时候，V8引擎就会在堆内存中分配给这变量，
继续申请：当已经申请的内存不足以存储这个变量的时候，V8引擎就会继续申请内存，知道堆内存大小达到V8引擎的内存上线位置

V8 引擎对对象的分代管理
新生代：存活周期较短的js 对象，如临时变量，字符串等
老生代：经过多次垃圾回收仍然存活，周期较长的对象，如控制权，服务器对象等

## 垃圾回收
引用计数：就是看一个对象是否有指向它的其他的引用，已过时
标记清除：将不再对象对象标记为无法到达的对象，从全局对象出发，定时扫描内存中的对象，凡是内到达根部的对象，其他则被标记为不在使用的对象，
稍后进行垃圾回收

## 内存泄漏：指的是不在使用的内存内有被即时释放，清除，就叫内存泄漏


#### 作用域和闭包
### 闭包：指有权访问另外一个函数内部作用域中的变量的函数
1、是一个函数
2、能访问另外一个函数作用域的变量

### 闭包的特性（优点，特点）
1、可以访问其他函数内部的变量
2、即使外部函数已经返回，闭包任然能够访问外部函数的变量
3、闭包可以更新外部变量的值
## 使用场景：
1、使用闭包实现递归调用如斐波那契数列
2、闭包实现块级作用域。如立即执行函数

### 闭包的缺点
1、会造成内存泄漏，闭包会让一些作用域内变量保持在内存中，即使函数已经运行返回，仍然保持对这些变量的引用，无法释放
2、闭包会当访问一个改变父级函数的变量，当把这些变量当做私有属性的时候需要格外注意，不能随意更改内部变量的值

### 作用域链
当访问一个变量的时候，解释器会首先在当前作用域查找标识符，如果没找到，就回去父作用域查找，直到找到该变量的标识符或者不在父级作用域中，这就形成了一条自下而上，由内往外的作用域链

<strong>与原型链的区别</strong>：原型链查找不到会返回undefined，但是作用域链查找不到会跑出错误RefenenceError