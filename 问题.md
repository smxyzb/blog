## websocket 保障

# 心跳检测和重连机制

1、创建 WebSocket 链接

```
function createWebSocket() {
  try {
    ws = new WebSocket(wsUrl);
    init();
  } catch(e) {
    console.log('catch');
    reconnect(wsUrl);
  }
}
```

2、初始化，利用 close 或者 error 方法

```
ws.onclose = function () {
  reconnect(url)
}

ws.onerror = function () {
  reconnect(url)
}

ws.onpoen = function () {
  // 心跳检测
  heartCheck.start()
}

ws.onmessage = function (event) {
    console.log('接收到消息');
    //拿到任何消息都说明当前连接是正常的
    heartCheck.start();
}

```

3、重连操作

```
var lockReconnect = false;//避免重复连接
function reconnect(url) {
      if(lockReconnect) {
        return;
      };
      lockReconnect = true;
      //没连接上会一直重连，设置延迟避免请求过多
      tt && clearTimeout(tt);
      tt = setTimeout(function () {
        createWebSocket(url);
        lockReconnect = false;
      }, 4000);
}
```

4、心跳检测

```
//心跳检测
var heartCheck = {
      timeout: 3000, //每隔三秒发送心跳
      num: 3,  //3次心跳均未响应重连
      timeoutObj: null,
      serverTimeoutObj: null,
      start: function(){
        var _this = this;
        var _num = this.num;
        this.timeoutObj && clearTimeout(this.timeoutObj);
        this.serverTimeoutObj && clearTimeout(this.serverTimeoutObj);
        this.timeoutObj = setTimeout(function(){
              //这里发送一个心跳，后端收到后，返回一个心跳消息，
              //onmessage拿到返回的心跳就说明连接正常
              ws.send("123456789"); // 心跳包
              _num--;
              //计算答复的超时次数
              if(_num === 0) {
                   ws.colse();
              }
        }, this.timeout)
      }
}
```

## 原型链 **proto**与 prototype 的关系

### 实例的 ** proto** 属性等于构造函数的原型，继承主要通过**proto**实现

```
function Animal(name) {
  this.name = name
}
Animal.prototype.bark = function () {
  console.log('bark');
}

var d = new Animal()

console.log(d.__proto__ === Animal.prototype);
```

同样:几种数据类型的 **proto** === Function.prototype

## meta 标签的 http-equiv content 的 cache-control 几个值的区别

```
1、max-age：单位是秒，缓存时间计算以发起时间的秒数计算，超过设置的时间则失效。

2、no-cache：不使用缓存，需要与服务器验证缓存新鲜度，也就是协商缓存。

3、no-store：禁止使用缓存（包括协商缓存）,每次都想服务器发起请求新的资源。

4、private：专用于个人缓存，中间代理、CDN 等不能缓存次响应。

5、public：响应可悲中间代理，CDN 等缓存。

6、must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证。
```



## 怎么理解 Vue 的渐进式

## Vue mergeOption 规则

## Vue 数组改变不重写方法

## diff 过程

## Vue-router 组件有那几个

## mixins 嵌套原理，Vuex Module 嵌套，extends

## Observer Compiler Wacther 的作用

## BeforeROuterEnter ，BeforeRouterLeave，参数，router 导航方法，跳转方式

## 组件多，页面卡顿的优化

## Vue 依赖收集过程，原理

## 列表位置缓存，列表到详情再返回怎么保证停留在原来的位置

## Vue Core 模块主要关注什么，主要任务

## created ，beforeUpdated 里面更改数据会出发 update 吗

## Vue mounted 循环为什么不会一直更新

## react 和 Vue 的区别

## redux 和 Vuex 的区别

## let，const 为什么不能重复定义

## Set 和 Map 是基于什么来遍历的，iterator 未完成时候 next 是什么

## Promise all trace 在其中有个 resolve 或者 reject 的情况

## EventLoop 
## 主线程，微任务，宏任务，Promise 是什么任务、
### "Event Loop是一个程序结构，用于等待和发送消息和事

## for forEach

## 如何捕获 await 内部错误

## es6 数组新方法有哪些，reduce 的用法

## ex6 Proxy 与 Reflect 的关系

## class 里面的 super 与 this 的区别

## 常用布局和适配方式

## flex 布局，flex 有哪些属性

## 居中问题

## 原生小程序 Object 的不写方法的兼容性

## http2

## webpack Tree-shaking 原理

## Electron 通讯，主进程与渲染进程的通讯

## webpack 怎么与 CDN 结合使用

## loader 和 plugin 的区别

## 函数科里化：所谓"柯里化"，就是把一个多参数的函数，转化为单参数函数

### 只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数

### 代码复用，减少维护成本

### 尽可能的函数化，便于阅读

## 防抖，节流原理，使用场景

## Promise 实现，手写 Promise

## Promise all trace 有一个 resolve，reject 的时候结果

## 实现 New 方法，apply，call，bind

```
function New() {
  // 1、创建一个空的对象
  var obj = new Object();
  // 2、获得构造函数，同时删除 arguments 中第一个参数
  console.log(arguments);
  var Con = [].shift.call(arguments);
  console.log(Con);
  // 3、链接到原型，obj 可以访问构造函数原型中的属性
  Object.setPrototypeOf(obj, Con.prototype);
  // 4、绑定 this 实现继承，obj 可以访问到构造函数中的属性
  var ret = Con.apply(obj, arguments);
  console.log(ret);
  // 5、优先返回构造函数返回的对象
  return ret instanceof Object ? ret : obj;
};
```

## Nginx 缓存配置，负载均衡

## 前端性能优化

## 组件封装设计思路

## 架构思想

## 二叉树

### 实现

### 获取二叉树深度

```
var maxDepth = function (root) {
  if (root === null) { //注意等号
    return 0;
  } else {
    var leftDepth = 0;
    var rightDepth = 0
    if (root) {
      console.log(root);
      leftDepth = maxDepth(root.left)
      console.log(leftDepth);
      rightDepth = maxDepth(root.right)
      console.log(rightDepth);
    }
    var childDepth = leftDepth > rightDepth ? leftDepth : rightDepth;

    return childDepth + 1;//根节点不为空高度至少为1
  }
};
```
